<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Day 20: Jurassic Jigsaw</title>

<style media="screen">
:root {--bg:#fff;--fg:#000;}
@media (prefers-color-scheme:dark) {:root {--bg:#202124;--fg:#f1f3f4;}}
body, body * {background:var(--bg); color:var(--fg);}
textarea {width: 8em; height: 40em;}
.flx {display:flex;}
.fm button {margin-left: 1em; margin-top: 2em;}
.fm p {margin-left:0.5em; line-height:2em; font-family:monospace;}
.tile {position:absolute; padding:0; margin:0;}
.tile img {display:block; padding:0; margin:0;}
.hi {filter:brightness(150%);}
kbd {padding:0.2em 0.4em 0.2em 0.4em; background-color:var(--fg); color:var(--bg); border-radius:0.25em;}
</style>
</head>
<body>

<div class="flx">

<div>
    <textarea id="input">Tile 2311:
..##.#..#.
##..#.....
#...##..#.
####.#...#
##.##.###.
##...#.###
.#.#.#..##
..#....#..
###...#.#.
..###..###

Tile 1951:
#.##...##.
#.####...#
.....#..##
#...######
.##.#....#
.###.#####
###.##.##.
.###....#.
..#.#..#.#
#...##.#..

Tile 1171:
####...##.
#..##.#..#
##.#..#.#.
.###.####.
..###.####
.##....##.
.#...####.
#.##.####.
####..#...
.....##...

Tile 1427:
###.##.#..
.#..#.##..
.#.##.#..#
#.#.#.##.#
....#...##
...##..##.
...#.#####
.#.####.#.
..#..###.#
..##.#..#.

Tile 1489:
##.#.#....
..##...#..
.##..##...
..#...#...
#####...#.
#..#.#.#.#
...#.#.#..
##.#...##.
..##.##.##
###.##.#..

Tile 2473:
#....####.
#..#.##...
#.##..#...
######.#.#
.#...#.#.#
.#########
.###.#..#.
########.#
##...##.#.
..###.#.#.

Tile 2971:
..#.#....#
#...###...
#.#.###...
##.##..#..
.#####..##
.#..####.#
#..#.#..#.
..####.###
..#.#.###.
...#.#.#.#

Tile 2729:
...#.#.#.#
####.#....
..#.#.....
....#..#.#
.##..##.#.
.#.####...
####.#.#..
##.####...
##..#.##..
#.##...##.

Tile 3079:
#.#.#####.
.#..######
..#.......
######....
####.#..#.
.#...#.##.
#.#####.##
..#.###...
..#.......
..#.###...
</textarea>
</div>

<div class="fm">
    <button type="button" name="button">Play</button>
    <p><kbd>R</kbd> rotate
        <br><kbd>F</kbd> flip X
        <br><kbd>V</kbd> flip Y
    </p>
</div>

<div id="gfx">
</div>

</div>

<script type="text/javascript">
let selectedTile, selectedOffX, selectedOffY, reselectTime
let draggingTile, dragDist
let canvasScale = 10
function documentMouseDown(event) {
    if (selectedTile) {
        selectedTile.classList.remove('hi')
        selectedTile = undefined
    }
}
function tileMouseDown(event) {
    if (event.ctrlKey || event.altKey || event.metaKey || event.button) {
        return
    }
    const view = event.target.parentNode
    event.preventDefault()
    event.stopPropagation()
    if (selectedTile) {
        selectedTile.classList.remove('hi')
    }
    reselectTime = (selectedTile === view) ? Date.now() : undefined
    selectedTile = draggingTile = view
    dragDist = 0
    selectedTile.classList.add('hi')
    const bounds = view.getBoundingClientRect()
    selectedOffX = event.clientX - bounds.left
    selectedOffY = event.clientY - bounds.top
    view.parentNode.appendChild(view)

    let board = document.getElementById('gfx')
    document.addEventListener('mousemove', onMouseMove)
    document.addEventListener('mouseup', onMouseUp)
}
function moveTo(view, x, y) {
    const parent = view.parentNode.getBoundingClientRect()
    view.style.left = x - parent.left - selectedOffX + 'px'
    view.style.top = y - parent.top - selectedOffY + 'px'
}

function onMouseMove(event) {
    if (draggingTile) {
        event.preventDefault()
        event.stopPropagation()
        dragDist += event.movementX + event.movementY
        moveTo(draggingTile, event.clientX, event.clientY)
        if (event.movementX + event.movementY < canvasScale * 2) {
            let other = collidDet(draggingTile)
            if (other) {
                if (snapTo(draggingTile, other, event.movementX, event.movementY)) {
                    draggingTile = undefined
                }
            }
        }
    }
}
function onMouseUp(event) {
    if (draggingTile) {
        moveTo(draggingTile, event.clientX, event.clientY)
        if ((draggingTile === selectedTile) && (dragDist == 0) && (Date.now() - reselectTime < 240)) {
            selectedTile.tile = flipxTile(selectedTile.tile)
            refreshTileImage(selectedTile)
        }
        draggingTile = undefined
    }
    document.removeEventListener('mousemove', onMouseMove)
    document.removeEventListener('mouseup', onMouseUp)
}
let lastWheel = 0
function onMouseWheel(event) {
    const now = Date.now()
    if (now - lastWheel > 240) {
        lastWheel = now
        if (event.ctrlKey || event.altKey || event.metaKey) {
            canvasScale = Math.max(1, canvasScale + (event.deltaY > 1 ? -1 : 1))
            rebuildTiles()
        }
        else if (event.target && event.target.parentNode.tile) {
            console.log(event)
            let view = event.target.parentNode
            view.tile = rotateTile(view.tile, (event.deltaY > 1) ? 270 : 90)
            refreshTileImage(view)
        }
        event.preventDefault()
    }
}
function onKeyDown(event) {
    if (selectedTile && !(event.repeat || event.metaKey || event.ctrlKey || event.altKey)) {
        switch (event.key) {
        case 'r': {
            selectedTile.tile = rotateTile(selectedTile.tile, 90)
            refreshTileImage(selectedTile)
            }
            break
        case 'R': {
            selectedTile.tile = rotateTile(selectedTile.tile, 270)
            refreshTileImage(selectedTile)
            }
            break
        case 'f': case 'F': {
            selectedTile.tile = flipxTile(selectedTile.tile)
            refreshTileImage(selectedTile)
            }
            break
        case 'v': case 'V': {
            selectedTile.tile = flipyTile(selectedTile.tile)
            refreshTileImage(selectedTile)
            }
            break
        }
    }
}
function renderTileImage(tile, scale=1) {
    const [w, h] = [tile.xs[0].length, tile.xs.length]
    let canvas = document.createElement('canvas')
    let gx = canvas.getContext('2d')
    gx.canvas.width = w * scale
    gx.canvas.height = h * scale
    gx.scale(scale, scale)
    const theme = {
        border: '#f535aa',
        sand: '#0c090a',
        wave: '#4863a0',
    }
    for (const [y, row] of tile.xs.entries()) {
        for (const [x, c] of row.entries()) {
            let color = theme.sand
            if (c) {
                const border = (y == 0 || x == 0 || y+1 == h || x+1 == w)
                color = border ? theme.border : theme.wave
            }
            gx.fillStyle = color
            gx.fillRect(x, y, 1, 1)
        }
    }
    return canvas.toDataURL()
}
function renderTile(tile, scale=1) {
    let data = renderTileImage(tile, scale)
    let im = new Image()
    im.src = data
    im.setAttribute('draggable', false)
    let view = document.createElement('div')
    view.tile = tile
    view.className = 'tile'
    view.setAttribute('title', tile.id)
    view.style['box-shadow'] = '0 0 ' + (scale-1) + 'px #666'
    view.appendChild(im)
    view.addEventListener('mousedown', tileMouseDown)
    view.addEventListener('wheel', onMouseWheel)
    return view
}
function refreshTileImage(view) {
    let data = renderTileImage(view.tile, canvasScale)
    let im = view.querySelector('img')
    im.src = data
}
function rebuildTiles() {
    let tiles = document.querySelectorAll('#gfx div .tile')
    for (const view of tiles) {
        refreshTileImage(view)
    }
}
function rotateTile(tile, angle) {
    const side = tile.xs.length
    let xs = tile.xs
    for (; angle > 0; angle -= 90) {
        let data = Array()
        for (let y = 0; y < side; ++y) {
            let row = Array()
            for (let x = side-1; x >= 0; --x) {
                row.push(xs[x][y])
            }
            data.push(row)
        }
        xs = data
    }
    return {id: tile.id, sig: tile.sig, xs: xs}
}
function flipxTile(tile, angle) {
    const bound = tile.xs.length - 1
    let xs = tile.xs.map(row => row.map((x, i) => row[bound-i]))
    return {id: tile.id, sig: tile.sig, xs: xs}
}
function flipyTile(tile, angle) {
    const bound = tile.xs.length - 1
    let xs = tile.xs.map((row, i) => tile.xs[bound-i])
    return {id: tile.id, sig: tile.sig, xs: xs}
}
function tileTop(tile) { return tile.xs[0] }
function tileBottom(tile) { return tile.xs[tile.xs.length-1] }
function tileLeft(tile) { return tile.xs.map(row => row[0]) }
function tileRight(tile) { return tile.xs.map(row => row[row.length-1]) }
function parseTile(s) {
    let lines = s.trim().split(/\n+/)
    let id = Number.parseInt(/\d+/.exec(lines[0]))
    let xs = lines.slice(1).map(s => s.split('').map(x => x === '#' ?1:0))
    let tile = {id, xs}
    tile.sig = [
        packnum(tileTop(tile)),
        packnum(reverse(tileTop(tile))),
        packnum(tileBottom(tile)),
        packnum(reverse(tileBottom(tile))),
        packnum(tileLeft(tile)),
        packnum(reverse(tileLeft(tile))),
        packnum(tileRight(tile)),
        packnum(reverse(tileRight(tile))),
    ]
    return tile
}
function reverse(a) {
    let b = a.slice(); b.reverse()
    return b
}
function packnum(a) {
    return a.reduce((acc, x) => (acc << 1) | x)
}
function shuffle(a) {
    for (let i = a.length-1; i > 0; --i) {
        const j = (Math.random() * (i + 1) | 0)
        const t = a[j]
        a[j] = a[i]
        a[i] = t
    }
}
let cpossible = undefined
function collidAdd(view) {
    if (!cpossible) {
        cpossible = new Map()
    }
    for (const s of view.tile.sig) {
        let ts = cpossible.get(s) || Array()
        ts.push(view)
        cpossible.set(s, ts)
    }
}
function collidDet(view) {
    let known = new Set()
    for (const x of view.tile.sig.flatMap(s => cpossible.get(s))) {
        known.add(x)
    }
    const mybounds = view.getBoundingClientRect()
    for (const other of known) {
        if (other === view) { continue }
        const bounds = other.getBoundingClientRect()
        if (collidNear(mybounds, bounds)) {
            const [sa, sb] = collidSidesNear(view, other, mybounds, bounds)
            if (sa && sb && packnum(sa) == packnum(sb)) {
                return other
            }
        }
    }
}
function collidNear(a, b) {
    const q = 1.25
    let dx = ((a.left + a.right) - (b.left + b.right)) / 2
    let dy = ((a.top + a.bottom) - (b.top + b.bottom)) / 2
    return (dx * dx + dy * dy) < (a.width * a.height * q)
}
function collidSidesNear(aview, bview, a, b) {
    const q = 0.15 * 2
    let va, vb
    let dx = Math.abs((a.left + a.right) - (b.left + b.right))
    if (dx < a.width * q) {
        if (a.top + a.height < b.top) {
            va = tileBottom(aview.tile)
            vb = tileTop(bview.tile)
        }
        else if (b.top + b.height < a.top) {
            va = tileTop(aview.tile)
            vb = tileBottom(bview.tile)
        }
    }
    let dy = Math.abs((a.top + a.bottom) - (b.top + b.bottom))
    if (dy < a.height * q) {
        if (a.left + a.width < b.left) {
            va = tileRight(aview.tile)
            vb = tileLeft(bview.tile)
        }
        else if (b.left + b.width < a.left) {
            va = tileLeft(aview.tile)
            vb = tileRight(bview.tile)
        }
    }
    return  [va, vb]
}
function snapTo(aview, bview, movedX, movedY) {
    const q = 0.2 * 2
    const a = aview.getBoundingClientRect()
    const b = bview.getBoundingClientRect()
    for (const [ox, oy] of [[b.left-a.width, b.top], [b.left, b.top-a.height], [b.left+b.width, b.top], [b.left, b.top+b.height]]) {
        const dx = Math.abs(ox - a.left)
        const dy = Math.abs(oy - a.top)
        if (dx + dy < a.width * q) {
            if (dx == dy || (dx > dy && Math.sign(movedX) == Math.sign(dx)) || (dx < dy && Math.sign(movedY) == Math.sign(dy))) {
                const parent = aview.parentNode.getBoundingClientRect()
                aview.style.left = ox - parent.left + 'px'
                aview.style.top = oy - parent.top + 'px'
                return true
            }
        }
    }
}
function startGame() {
    document.querySelector('.fm button').blur()
    let input = document.getElementById('input').value
    let tiles = input.trim().split(/\n\n/).map(parseTile)
    shuffle(tiles)
    const scale = canvasScale
    const side = Math.sqrt(tiles.length) | 0
    cpossible = undefined

    const solution0 = 0

    let inner = document.createElement('div')
    const [inx, iny] = [side * scale * 10, side * scale]
    for (const tile of tiles) {
        let view = renderTile(tile, scale)
        collidAdd(view)
        inner.appendChild(view)
        let x, y
        if (solution0) {
            const i = solution0.indexOf(tile.id)
            x = (i % side) * (tile.xs[0].length + 1) * scale
            y = (i / side | 0) * (tile.xs.length + 1) * scale
        }
        else {
            [y, x] = [Math.random()*iny|0, Math.random()*inx|0]
        }
        view.style.left = x + 'px'
        view.style.top = y + 'px'
    }

    inner.style.position = 'relative'
    inner.style.left = '2em'
    let board = document.getElementById('gfx')
    let prev = board.querySelector('div')
    if (prev) {
        board.replaceChild(inner, prev)
    }
    else {
        board.appendChild(inner)
    }

}
function setupApp() {
    document.querySelector('.fm button').addEventListener('click', startGame)
    document.addEventListener('keydown', onKeyDown)
    document.addEventListener('mousedown', documentMouseDown)
}
window.addEventListener('DOMContentLoaded', setupApp)
</script>
</body>
</html>
